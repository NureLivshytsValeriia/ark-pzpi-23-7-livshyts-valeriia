МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК
КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ



ЗВІТ
до практичного завдання №2 з дисципліни
«Аналіз та рефакторинг коду»
на тему: «Методи рефакторингу коду програмного забезпечення»





Виконав:                                                                                                  Перевірив:
ст. гр. ПЗПІ-23-7                       				ст. викладач кафедри ПІ
Лівшиць Валерія Сергіївна		                    	         Сокорчук Ігор Петрович





Харків 2025
 
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	05.11.2025	1	Створено звіт

 
2 ВСТУП
У процесі розробки програмного забезпечення код часто еволюціонує, доповнюється новими функціями, змінюється структура класів та взаємозв’язки між ними. З часом це може призвести до появи дублювань, надмірної складності або зниження читабельності програмного коду. Саме тому важливим етапом життєвого циклу програмного продукту є рефакторинг — удосконалення внутрішньої структури коду без зміни його зовнішньої поведінки.
Метою рефакторингу є підвищення якості програмного коду, спрощення його розуміння, підтримки та повторного використання. Існує безліч методів рефакторингу, кожен з яких спрямований на вирішення конкретних проблем, що виникають у процесі проєктування або розвитку системи.
У даній роботі розглянуто три поширені методи рефакторингу:
•	Pull Up Method — підняття методу з підкласів у суперклас для усунення дублювання;
•	Move Field — переміщення поля з одного класу в інший, де воно використовується частіше;
•	Self Encapsulate Field — інкапсуляція поля через створення геттерів і сеттерів для контролю доступу.
Розгляд цих методів супроводжується прикладами реалізації на мові C#, що демонструє практичне застосування технік рефакторингу для покращення структури та якості коду.

 
3 ОПИС ВИКОНАНОЇ РОБОТИ

3.1 Метод Pull Up Method (Підняття методу)
Метод Pull Up Method використовується для усунення дублювання коду шляхом переміщення однакових або схожих методів із підкласів до суперкласу. Це дозволяє централізувати спільну логіку, спростити структуру класів і забезпечити повторне використання коду.

Причини рефакторингу:
•	Декілька підкласів мають методи з однаковою логікою.
•	Виникає дублювання коду в класах однієї ієрархії.
•	Методи виконують однакову або подібну функцію.
Переваги:
•	Зменшення дублювання коду.
•	Спрощення подальшої підтримки та модифікації.
•	Підвищення повторного використання коду.
Порядок рефакторингу:
1.	Перевірити, чи є методи в підкласах ідентичними. Якщо є відмінності — привести їх до однакового вигляду.
2.	Переконатися, що всі допоміжні методи, які викликаються з цього методу, доступні в суперкласі.
3.	Створити аналогічний метод у суперкласі та скопіювати до нього код із підкласу.
4.	Видалити дубльовані методи з підкласів.
5.	Перевірити працездатність усієї програми.

Приклад С#:
До рефакторингу:

1	class Employee {
2	  protected string name;
3	  protected double salary;
4	}
5	
6	class Manager : Employee {
7	  public string GetInfo() {
8	     return $"Name: {name}, Salary: {salary}";
9	  }
10	}
11	
12	class Engineer : Employee {
13	  public string GetInfo() {
14	    return $"Name: {name}, Salary: {salary}";
15	  }
16	}

Після рефакторингу:

1	 class Employee {
2	  protected string name;
3	  protected double salary;
4	
5	  public string GetInfo() {
6	    return $"Name: {name}, Salary: {salary}";
7	  }
8	 } 
9	
10	 class Manager : Employee { }
11	 class Engineer : Employee { }

Результат:
Метод GetInfo() був перенесений до суперкласу Employee, що усунуло
дублювання та зробило код більш узгодженим.

3.2 Метод Move Field (Переміщення поля)
Метод Move Field застосовується, коли певне поле логічно належить іншому класу або використовується частіше саме там. У результаті поле переноситься до більш доречного класу, що покращує архітектуру програми.

Причини рефакторингу:
•	Поле частіше використовується в іншому класі.
•	Виникає надмірна залежність між класами.
•	Клас має занадто багато обов’язків або перевантажений логікою.
Переваги:
•	Зменшення зв’язності між класами.
•	Групування пов’язаних даних у межах відповідного класу.
•	Покращення читабельності та підтримуваності коду.
Порядок рефакторингу:
1.	Зробити поле приватним і додати до нього геттери/сеттери.
2.	Створити аналогічне поле в цільовому класі.
3.	Налаштувати звернення до нового поля через відповідний об’єкт.
4.	Замінити всі звернення до старого поля.
5.	Видалити старе поле після перевірки.

Приклад С#:
До рефакторингу:

1	class Account {
2	  private double interestRate = 0.05;
3	
4	  public double CalculateInterest(int days) {
5	    return interestRate * days;
6	  }
7	}
8	
9	class AccountType {
10	  private string name;
11	
12	  public bool IsPremium() {
13	    return name == "Premium";
14	  }
15	}
Після рефакторингу:

1	class Account {
2	  private AccountType accountType;
3	
4	  public double CalculateInterest(int days) {
5	    return accountType.InterestRate * days;
6	  }
7	}
8	
9	class AccountType {
10	  private string name;
11	  public double InterestRate { get; set; }
12	
13	  public bool IsPremium() {
14	    return name == "Premium";
15	  }
16	}

Результат:
Поле interestRate було перенесене до класу AccountType, де воно використовується частіше. Це зменшило залежність між класами та зробило логіку більш логічною.

3.3 Метод Self Encapsulate Field (Самоінкапсуляція поля)
Метод Self Encapsulate Field полягає у створенні геттерів і сеттерів для прямого доступу до поля. Це дає змогу контролювати зміну значення, додавати перевірки, логіку чи обчислення без зміни інтерфейсу класу.

Причини рефакторингу:
•	Необхідність додати логіку при зміні або читанні поля.
•	Бажання забезпечити контроль доступу до поля.
•	Підготовка до можливого розширення функціональності.
Переваги:
•	Краща інкапсуляція даних.
•	Можливість розширення без зміни інтерфейсу.
•	Збільшення гнучкості й безпечності коду.
Порядок рефакторингу:
1.	Створити геттер і сеттер для поля.
2.	Замінити прямі звернення до поля викликами цих методів.
3.	Зробити саме поле приватним.
4.	Переконатися, що весь код використовує нові методи.

Приклад С#:
До рефакторингу:

1	class Product {
2	   private double price;
3	
4	   public double GetDiscountedPrice() {
5	     if (price > 100) {
6	       return price * 0.9;
7	     }
8	     return price;
9	   }
10	   public void SetSpecialPrice(double newPrice) {
11	     price = newPrice * 1.1;
12	   }
13	 }

Після рефакторингу:

1	class Product {
2	  private double price;
3	
4	  private double Price {
5	    get { return price; }
6	    set { price = value; }
7	  }
8	
9	  public double GetDiscountedPrice() {
10	    if (Price > 100) {
11	      return Price * 0.9;
12	    }
13	    return Price;
14	  }
15	
16	  public void SetSpecialPrice(double newPrice) {
17	    Price = newPrice * 1.1;
18	  }
19	}

Результат:
Поле price було інкапсульовано через властивість Price, що дало змогу контролювати зміну значення та забезпечити кращу безпечність доступу. 
ВИСНОВКИ

У результаті виконання практичної роботи було розглянуто та проаналізовано три важливі методи рефакторингу коду: Pull Up Method (Підняття методу), Move Field (Переміщення поля) та Self Encapsulate Field (Самоінкапсуляція поля). 
Метод Pull Up Method дозволяє усунути дублювання коду в підкласах шляхом перенесення спільної логіки до суперкласу. Це не лише спрощує супровід програми, але й робить архітектуру системи більш логічною та узгодженою. 
Метод Move Field спрямований на підвищення зрозумілості та логічної цілісності класів. Переміщення поля до того класу, де воно дійсно використовується, зменшує зв’язність між компонентами та сприяє більш чіткому розподілу обов’язків. Такий підхід допомагає підтримувати принцип Single Responsibility Principle (SRP) — один із ключових принципів SOLID, що є фундаментом для створення надійних та масштабованих систем.
Метод Self Encapsulate Field забезпечує інкапсуляцію даних і контроль доступу до внутрішнього стану об’єктів. Завдяки створенню геттерів та сеттерів можна додавати додаткову логіку при зміні або отриманні значень, не порушуючи зовнішній інтерфейс класу. Це підвищує гнучкість коду, дозволяє безпечно модифікувати його поведінку в майбутньому, а також покращує захищеність від непередбачених змін.
Усі три методи мають спільну мету — зробити програмний код більш чистим, зрозумілим та легким у подальшій підтримці. Їх застосування зменшує ризик появи помилок, полегшує тестування, забезпечує можливість повторного використання компонентів та сприяє дотриманню принципів об’єктно-орієнтованого програмування. У процесі виконання роботи були створені та протестовані приклади реалізації зазначених методів мовою C#, що демонструє універсальність і практичну цінність цих підходів у сучасній розробці.
ВИКОРИСТАНІ ДЖЕРЕЛА

1.	Design Patterns and Refactoring. Design Patterns & Refactoring. URL: https://sourcemaking.com/refactoring (дата звернення: 05.11.2025).
2.	Martin Fowler — Refactoring: Improving the Design of Existing Code. URL:  https://martinfowler.com/books/refactoring.htmll (дата звернення: 05.11.2025).
3.	Programming Concepts - C#. Microsoft Learn: Build skills that open doors in your career. URL: https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/ (дата звернення: 05.11.2025).
4.	Robert C. Martin — Clean Code: A Handbook of Agile Software Craftsmanship. URL: https://github.com/Gatjuat-Wicteat-Riek/clean-code-book (дата звернення: 05.11.2025).
 
ДОДАТОК А
Відеозапис

Відеозапис доповіді: https://youtu.be/ORKeL3Nwdq4

Хронологічний опис відеозапису:
0:00 - Вступ 
0:41 - Методи що будуть розглянуті 
1:06 - Pull Up Method 
3:23 - Move Field 
5:19 - Self Encapsulate Field 
7:49 - Висновки
 

ДОДАТОК Б
Слайди презентації

 
Рисунок Б.1 – Титульний слайд презентації
 
Рисунок Б.2 – Методи що будуть розглянуті

 
Рисунок Б.3 – Метод Pull Up

 
Рисунок Б.4 – Порядок рефакторингу методу Pull Up

 
Рисунок Б.5 - Приклад методу Pull Up

 
Рисунок Б.6 – Метод Move Field

  Рисунок Б.7 – Порядок рефакторингу методу Move Field

 
Рисунок Б.8 - Приклад методу Move Field
 
Рисунок Б.9 – Метод Self Encapsulate Field

 
Рисунок Б.10 – Порядок рефакторингу методу Self Encapsulate Field

 
Рисунок Б.11 - Приклад методу Self Encapsulate Field

 
Рисунок Б.12 - Висновок


